const editor = CodeMirror.fromTextArea(document.getElementById("editor"), {
    lineNumbers: true,
    mode: "z80",
    styleActiveLine: true,
    theme: "solarized dark"
});

function get_bytes(obj) {
    var bytes = [];
    obj.dump.forEach(function(entry) {
        if (!entry.lens) return;
        /* Concat the two arrays */
        bytes.push(...entry.lens);
    });
    return bytes;
}

async function assemble() {
    const code = editor.getValue();
    try {
        const result = await ASM.compile(code, { readFile: () => 0 }, { assembler: 'z80'});
        console.log("Assembly Result:", result);
        document.getElementById("log").className = "log";
        document.getElementById("log").textContent = "Assembly successful. Generated bytes:";
        const bytes = get_bytes(result);
        document.getElementById("hex-view").textContent = bytes.map(b => b.toString(16).padStart(2, '0')).join(' ');
        return bytes;
    } catch (e) {
        const error = e.error;
        document.getElementById("log").className = "log error";
        if (error.s) {
            document.getElementById("log").textContent = `❌ Error on line ${error.s.numline}: ${error.msg}`;
        } else {
            document.getElementById("log").textContent = "❌ Error: " + error.msg;
        }
        console.error("❌ Assembly Error:", error);
        return [];
    }
}


async function code_run() {
    const bytes = await assemble();
    console.log(bytes);
    /* If we have some bytes, load them to the VFS */
    const data = new Uint8Array(bytes);
    FS.writeFile('/roms/default.img', data);
    Module._main();
}

/* WebASM related */
const canvas = document.getElementById('canvas');
canvas.addEventListener('click', () => {
    canvas.focus();
    enableRaylibInput();
});

canvas.addEventListener("blur", () => {
    disableRaylibKeyboard();
});

let savedKeyCallback = null;
let savedCharCallback = null;


function disableRaylibKeyboard() {
    if (typeof GLFW === 'undefined' || !GLFW.active) return;
    /* Get the GLFW window */
    const id = GLFW.active.id;
    savedKeyCallback = GLFW.active.keyFunc;
    savedCharCallback = GLFW.active.charFunc;
    GLFW.setKeyCallback(id, null); // disables keyboard input
    GLFW.setCharCallback(id, null); // disables text input
}

function enableRaylibInput() {
    if (typeof GLFW !== 'undefined' && GLFW.active) {
        const id = GLFW.active.id;
        GLFW.setKeyCallback(id, savedKeyCallback);
        GLFW.setCharCallback(id, savedCharCallback);
    }
}


var Module = {
    print: function(text) {
            console.log("Log: " + text);
        },
        printErr: function(text) {
            console.log("Error: " + text);
    },
    canvas: (function() {
        return canvas;
    })(),
    postRun: function() {
        disableRaylibKeyboard();
    },
    noInitialRun: true,
};
// Module.noInitialRun = true;
// Module.noExitRuntime = true;
// Module.dontCaptureKeyboard = true;
