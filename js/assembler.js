function get_bytes(obj) {
  var bytes = [];
  var pc = -1;
  obj.dump.forEach(function (entry) {
    if (!entry.lens) return;
    /* Initialize the PC if not initialized yet */
    if (pc == -1) {
      pc = entry.addr;
    } else if (pc < entry.addr) {
      /* Gap between current PC and the instruction address */
      for (var i = 0; i < entry.addr - pc; i++) {
        bytes.push(0x00);
      }
      pc = entry.addr;
    }
    /* Concat the two arrays */
    bytes.push(...entry.lens);
    pc += entry.lens.length;
  });
  return bytes;
}

async function assemble() {
  // return assemble_asm80();
  const code = editor.getValue();
  editor.clearErrors();

  function log(prefix = '') {
    return (text, ...args) => {
      console.log(prefix, text, ...args);
    };
  }

  const fileName = editor.fileName ?? 'main.asm';
  const OUTPUT = {
    as: null,
    ld: null,
    objcopy: null,
  };
  const asModule = {
    arguments: ['-g', `-alh=/user/${fileName}.lst`, '-o', `/user/${fileName}.o`, `/user/${fileName}`],
    print: log('info'),
    printErr: log('error'),
    onRuntimeInitialized: async function () {
      this.FS.mkdir('/user');
      this.FS.writeFile(`/user/${fileName}`, code);
    },
  };

  const ldModule = {
    arguments: ['-Ttext', '0x4000', '-o', `/user/${fileName}.elf`, `-Map=/user/${fileName}.map`, `/user/${fileName}.o`],
    print: log('info'),
    printErr: log('error'),
    onRuntimeInitialized: async function () {
      this.FS.mkdir('/user');
      this.FS.writeFile(`/user/${fileName}.o`, OUTPUT.as);
    },
  };

  const objcopyModule = {
    arguments: [
      '--only-section=.text',
      '--only-section=.data',
      '-O',
      'binary',
      `/user/${fileName}.elf`,
      `/user/${fileName}.bin`,
    ],
    print: log('info'),
    printErr: log('error'),
    onRuntimeInitialized: async function () {
      this.FS.mkdir('/user');
      this.FS.writeFile(`/user/${fileName}.elf`, OUTPUT.ld);
    },
  };

  return new Promise((resolve) => {
    GnuAsModule(asModule).then(async (mod) => {
      instance = mod;

      setTimeout(() => {
        const bytes = mod.FS.readFile(`/user/${fileName}.o`);
        console.log('as', 'bytes', bytes);
        const listing = mod.FS.readFile(`/user/${fileName}.lst`, { encoding: 'utf8' });
        console.log('as', 'list', listing);
        // const blob = new Blob([bytes], { type: 'application/octet-stream' });
        // console.log('as', 'blob', blob);
        OUTPUT.as = bytes;

        GnuLdModule(ldModule).then(async (mod) => {
          instance = mod;
          setTimeout(() => {
            const bytes = mod.FS.readFile(`/user/${fileName}.elf`);
            console.log('ld', 'bytes', bytes);
            const map = mod.FS.readFile(`/user/${fileName}.map`, { encoding: 'utf8' });
            console.log('ld', 'map', map);

            OUTPUT.ld = bytes;

            GnuObjCopyModule(objcopyModule).then(async (mod) => {
              instance = mod;
              setTimeout(() => {
                const bytes = mod.FS.readFile(`/user/${fileName}.bin`);
                OUTPUT.objcopy = bytes;
                console.log('objcopy', 'bytes', bytes);
                resolve({ bytes, listing, map });
              }, 500);
            });
          });
        });
      }, 500);
    });
  }).then(({ bytes, listing, map }) => {
    document.getElementById('log').className = 'log';
    document.getElementById('log').textContent = 'Assembly successful. Generated bytes:';

    const hexView = document.getElementById('hex-view');
    const listView = document.getElementById('list-view');
    const hex = bytes
      .map((b, i) => b.toString(16).padStart(2, '0'))
      .reduce((acc, byte, i) => {
        if (i % 16 === 0) {
          acc += i.toString(16).padStart(4, '0') + ': ';
        }
        acc += byte + ' ';
        if ((i + 1) % 16 === 0) {
          acc += '\n';
        }

        return acc;
      }, '');

    hexView.textContent = hex;
    listView.textContent = listing + `\n\n\nGLD MAP /user/${fileName}\n` + map;

    return bytes;
  });
}

async function assemble_asm80() {
  const code = editor.getValue();

  // clear previous errors, if any
  editor.clearErrors();

  async function readFile(path) {
    const { text } = await explorer.readFile(path);
    return text;
  }

  try {
    const result = await ASM.compile(code, { readFile }, { assembler: 'z80' });
    console.log('Assembly Result:', result);
    document.getElementById('log').className = 'log';
    document.getElementById('log').textContent = 'Assembly successful. Generated bytes:';

    const list = ASM.lst(result, true, true);

    const bytes = get_bytes(result);
    const hexView = document.getElementById('hex-view');
    const listView = document.getElementById('list-view');
    const hex = bytes
      .map((b, i) => b.toString(16).padStart(2, '0'))
      .reduce((acc, byte, i) => {
        if (i % 16 === 0) {
          acc += i.toString(16).padStart(4, '0') + ': ';
        }
        acc += byte + ' ';
        if ((i + 1) % 16 === 0) {
          acc += '\n';
        }

        return acc;
      }, '');

    hexView.textContent = hex;
    listView.textContent = list;
    return bytes;
  } catch (e) {
    const error = e.error;
    document.getElementById('log').className = 'log error';
    if (error.s) {
      console.warn(error);
      /* If the error comes from an included file, `error.s.includedFile` is defined  */
      let file = error.s.includedFile || editor.editor.fileName;
      document.getElementById('log').textContent = `❌ Error ${file}:${error.s.numline}: ${error.msg}`;
      /* If the error is in an included file, show the include as the error */
      let line = error.s.includedFileAtLine || error.s.numline;
      editor.gotoLine(line - 1, { error: true });
    } else {
      document.getElementById('log').textContent = '❌ Error: ' + error.msg;
    }
    console.error('❌ Assembly Error:', error);
    return [];
  }
}
