function get_bytes(obj) {
  var bytes = [];
  var pc = -1;
  obj.dump.forEach(function (entry) {
    if (!entry.lens) return;
    /* Initialize the PC if not initialized yet */
    if (pc == -1) {
      pc = entry.addr;
    } else if (pc < entry.addr) {
      /* Gap between current PC and the instruction address */
      for (var i = 0; i < entry.addr - pc; i++) {
        bytes.push(0x00);
      }
      pc = entry.addr;
    }
    /* Concat the two arrays */
    bytes.push(...entry.lens);
    pc += entry.lens.length;
  });
  return bytes;
}

/**
 * Recursively parse assembly source strings for `.include` directives in the browser.
 *
 * @param {string} rootUrl   - Base URL for resolving relative includes (where the root file is located).
 * @param {string} rootName  - A key name for the root file (e.g. "main.asm").
 * @param {string} rootSource - The contents of the root file (already provided).
 * @param {object} results   - Object to store file contents by filename.
 * @param {Set<string>} visited - Tracks visited URLs to prevent infinite loops.
 * @returns {Promise<object>} results - { "filename.asm": "contents", ... }
 */
async function parseIncludesFromString(rootUrl, rootName, rootSource, results = {}, visited = new Set()) {
  // Prevent reprocessing same "file"
  if (visited.has(rootName)) {
    return results;
  }
  visited.add(rootName);

  // Store the provided source
  results[rootName] = rootSource;

  // Regex for `.include "something"`
  const includeRegex = /^\s*\.include\s+"([^"]+)"\s*$/gm;

  let match;
  while ((match = includeRegex.exec(rootSource)) !== null) {
    const includePath = match[1];
    const includeUrl = new URL(`files/headers/gnu-as/${includePath}`, rootUrl);

    if (!visited.has(includeUrl)) {
      // Fetch included file
      const response = await fetch(includeUrl.href);
      if (!response.ok) {
        throw new Error(`Failed to load ${includeUrl}: ${response.statusText}`);
      }
      const includeSource = await response.text();

      // Recurse using the fetched contents
      await parseIncludesFromString(
        rootUrl, // new URL('./', includeUrl).href, // new base for further includes
        includeUrl.pathname, // use URL as the key
        includeSource,
        results,
        visited,
      );
    }
  }

  return results;
}

async function assemble() {
  // return assemble_asm80();
  const code = editor.getValue();
  editor.clearErrors();

  const fileName = editor.fileName ?? 'main.asm';
  // const files = await parseIncludesFromString(
  //   location.href + '/files/headers', // base path for includes
  //   fileName, // key for the root file
  //   code, // the initial contents
  // );
  // console.log(files);

  const hexView = document.getElementById('hex-view');
  hexView.textContent = '';
  const listView = document.getElementById('list-view');

  const toolchain = new GnuToolchain();
  const { bin, listing, map, errors } = await toolchain.execute(fileName, code).catch((errors) => {
    errors.forEach((err) => console.error(err.source, err.message));

    return { bin: null, listing: null, map: null, errors };
  });

  if (!bin) {
    console.error('no binary file was produced, check for errors');
    document.getElementById('log').className = 'log error';
    document.getElementById('log').textContent = 'No binary file was produced, check for errors';
    errors?.forEach((err) => {
      hexView.textContent += `${err.source}: ${err.message}\n`;
    });
    return;
  }

  document.getElementById('log').className = 'log';
  document.getElementById('log').textContent = 'Assembly successful. Generated bytes:';

  const hex = bin
    .map((b, i) => b.toString(16).padStart(2, '0'))
    .reduce((acc, byte, i) => {
      if (i % 16 === 0) {
        acc += i.toString(16).padStart(4, '0') + ': ';
      }
      acc += byte + ' ';
      if ((i + 1) % 16 === 0) {
        acc += '\n';
      }

      return acc;
    }, '');

  hexView.textContent = hex;
  listView.textContent = listing + `\n\n\nGLD MAP /user/${fileName}\n` + map;

  return bin;
}

async function assemble_asm80() {
  const code = editor.getValue();

  // clear previous errors, if any
  editor.clearErrors();

  async function readFile(path) {
    const { text } = await explorer.readFile(path);
    return text;
  }

  try {
    const result = await ASM.compile(code, { readFile }, { assembler: 'z80' });
    console.log('Assembly Result:', result);
    document.getElementById('log').className = 'log';
    document.getElementById('log').textContent = 'Assembly successful. Generated bytes:';

    const list = ASM.lst(result, true, true);

    const bytes = get_bytes(result);
    const hexView = document.getElementById('hex-view');
    const listView = document.getElementById('list-view');
    const hex = bytes
      .map((b, i) => b.toString(16).padStart(2, '0'))
      .reduce((acc, byte, i) => {
        if (i % 16 === 0) {
          acc += i.toString(16).padStart(4, '0') + ': ';
        }
        acc += byte + ' ';
        if ((i + 1) % 16 === 0) {
          acc += '\n';
        }

        return acc;
      }, '');

    hexView.textContent = hex;
    listView.textContent = list;
    return bytes;
  } catch (e) {
    const error = e.error;
    document.getElementById('log').className = 'log error';
    if (error.s) {
      console.warn(error);
      /* If the error comes from an included file, `error.s.includedFile` is defined  */
      let file = error.s.includedFile || editor.editor.fileName;
      document.getElementById('log').textContent = `❌ Error ${file}:${error.s.numline}: ${error.msg}`;
      /* If the error is in an included file, show the include as the error */
      let line = error.s.includedFileAtLine || error.s.numline;
      editor.gotoLine(line - 1, { error: true });
    } else {
      document.getElementById('log').textContent = '❌ Error: ' + error.msg;
    }
    console.error('❌ Assembly Error:', error);
    return [];
  }
}
